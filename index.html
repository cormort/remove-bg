<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºæ…§å½±åƒå·¥å…· v12.0 (å°ˆæ¥­é‡æ§‹ç‰ˆ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        :root { --bg: #1e1e2e; --panel: #2b2b3d; --accent: #e67e22; --text: #eceff4; --border: #444; --secondary-btn: #555; --blue-btn: #3498db; --danger: #e74c3c; }
        body { font-family: "Segoe UI", sans-serif; background-color: var(--bg); color: var(--text); margin: 0; padding: 20px; min-height: 100vh; }
        * { box-sizing: border-box; }
        h2 { border-bottom: 2px solid var(--accent); padding-bottom: 10px; margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; }
        
        /* Layout */
        .main-layout { display: grid; grid-template-columns: 320px 1fr; gap: 20px; }
        .controls { background: var(--panel); padding: 20px; border-radius: 8px; border: 1px solid var(--border); position: sticky; top: 20px; height: fit-content; max-height: 90vh; overflow-y: auto; }
        
        /* Components */
        .control-group { margin-bottom: 20px; border-bottom: 1px solid #444; padding-bottom: 15px; }
        .control-group:last-child { border-bottom: none; }
        .control-group.hidden { display: none !important; }
        
        .control-header { display: flex; justify-content: space-between; font-size: 0.9rem; margin-bottom: 8px; color: #bbb; font-weight: 600; }
        .control-val { color: var(--accent); }
        .sub-label { font-size: 0.8rem; color: #888; margin-top: 4px; display: block; line-height: 1.4; }
        
        input[type="range"] { width: 100%; cursor: pointer; accent-color: var(--accent); margin: 8px 0; }
        
        .toggle-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; cursor: pointer; background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px; transition: background 0.2s; }
        .toggle-row:hover { background: rgba(255,255,255,0.05); }
        .toggle-row input { margin-right: 10px; transform: scale(1.2); cursor: pointer; }

        .radio-group { display: flex; flex-direction: column; gap: 8px; background: rgba(0,0,0,0.2); padding: 10px; border-radius: 4px; margin-top: 10px;}
        .radio-item { display: flex; align-items: center; cursor: pointer; font-size: 0.9rem; }
        .radio-item input { margin-right: 8px; accent-color: var(--accent); transform: scale(1.1); }
        
        .btn { background: var(--accent); color: #fff; border: none; padding: 12px; border-radius: 4px; cursor: pointer; font-weight: bold; width: 100%; margin-bottom: 10px; transition: 0.2s; font-size: 1rem; display: flex; align-items: center; justify-content: center; gap: 8px; }
        .btn:hover { filter: brightness(1.1); transform: translateY(-1px); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { background: #444; color: #888; cursor: not-allowed; transform: none; }
        .btn.secondary { background: var(--secondary-btn); }
        .btn.blue { background: var(--blue-btn); }
        
        input[type="file"] { display: none; }

        /* Tabs */
        .tab-container { display: flex; gap: 10px; margin-bottom: 15px; }
        .tab-btn { flex: 1; padding: 12px; background: var(--panel); border: 1px solid var(--border); color: #888; cursor: pointer; border-radius: 8px 8px 0 0; font-weight: bold; transition: 0.3s; }
        .tab-btn.active { background: var(--accent); color: white; border-color: var(--accent); border-bottom: none; }
        .tab-btn:hover:not(.active) { background: #333; }

        /* Display Area */
        .display-wrapper { position: relative; display: flex; flex-direction: column; height: 100%; }
        .toolbar { display: flex; justify-content: flex-end; gap: 10px; margin-bottom: 10px; align-items: center; }
        .zoom-controls { display: flex; gap: 5px; background: var(--panel); padding: 4px; border-radius: 4px; border: 1px solid var(--border); }
        .zoom-btn { width: 30px; height: 30px; border: none; background: transparent; color: #fff; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; }
        .zoom-btn:hover { background: rgba(255,255,255,0.1); }

        .display-area { 
            background: var(--panel);
            flex: 1; min-height: 600px;
            border: 2px dashed #444; border-radius: 8px; padding: 20px; position: relative; 
            overflow: hidden; /* For zoom */
            outline: none;
        }
        .display-area.dragover { border-color: var(--accent); background: rgba(230, 126, 34, 0.1); }
        
        /* Canvas & Grid */
        .scroll-container { width: 100%; height: 100%; overflow: auto; display: flex; justify-content: center; align-items: flex-start; }
        .canvas-container { transition: transform 0.2s ease-out; transform-origin: top center; }
        .checker-bg { background-image: linear-gradient(45deg, #555 25%, transparent 25%, transparent 75%, #555 75%, #555), linear-gradient(45deg, #555 25%, transparent 25%, transparent 75%, #555 75%, #555); background-size: 20px 20px; background-color: #333; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        
        .brush-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 15px; width: 100%; }
        .brush-card { background: #222; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; display: flex; flex-direction: column; animation: fadeIn 0.3s ease; }
        .brush-preview { height: 180px; padding: 20px; display: flex; align-items: center; justify-content: center; background: #fff; position: relative; }
        .brush-preview::before { content:''; position: absolute; inset:0; background-image: linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd), linear-gradient(45deg, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%, #ddd); background-size: 20px 20px; opacity: 0.5; z-index: 0; }
        .brush-preview svg, .brush-preview img { width: 100%; height: 100%; object-fit: contain; position: relative; z-index: 1; }
        .brush-info { padding: 10px; background: #2b2b3d; border-top: 1px solid #444; }
        .brush-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 5px; }
        .sm-btn { padding: 5px; font-size: 0.8rem; border: none; border-radius: 4px; cursor: pointer; background: #444; color: #ccc; }
        .sm-btn:hover { background: #666; color: white; }

        /* Loading & Indicators */
        .loading-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        .loading-overlay.active { opacity: 1; pointer-events: all; }
        .spinner { width: 50px; height: 50px; border: 5px solid #444; border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
        .loading-text { color: white; font-weight: bold; font-size: 1.2rem; }
        
        #pasteIndicator { position: fixed; top: 20px; right: 20px; background: #2ecc71; color: white; padding: 10px 20px; border-radius: 4px; font-weight: bold; transform: translateY(-100px); transition: transform 0.3s; z-index: 100; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        #errorToast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%) translateY(100px); background: var(--danger); color: white; padding: 12px 24px; border-radius: 4px; font-weight: bold; transition: transform 0.3s; z-index: 100; }
        
        .empty-hint { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #666; pointer-events: none; }

        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

    <div class="loading-overlay" id="loader">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">æ­£åœ¨è™•ç†å½±åƒ...</div>
    </div>
    <div id="pasteIndicator">ğŸ“‹ å·²è²¼ä¸Šåœ–ç‰‡</div>
    <div id="errorToast">âš ï¸ ç™¼ç”ŸéŒ¯èª¤</div>

    <h2>
        <span>ğŸ§¬ æ™ºæ…§å½±åƒå·¥å…· v12.0</span>
        <small style="font-size: 0.8rem; color:#666; font-weight: normal;">Ctrl+Z å¾©åŸ | Ctrl+S ä¸‹è¼‰</small>
    </h2>

    <div class="main-layout">
        <div class="controls">
            <button class="btn" onclick="document.getElementById('fileInput').click()">ğŸ“‚ é–‹å•Ÿåœ–ç‰‡</button>
            <input type="file" id="fileInput" accept="image/png, image/jpeg, image/webp">
            
            <div style="display:flex; gap:10px; margin-bottom:20px;">
                <button class="btn secondary" style="flex:1; margin:0;" onclick="State.undo()" id="btnUndo" disabled>â†©ï¸ å¾©åŸ</button>
                <button class="btn secondary" style="flex:1; margin:0;" onclick="App.process()" id="btnRedo">âš¡ é‡ç®—</button>
            </div>

            <div class="control-group">
                <div class="control-header">1. å½±åƒå‰è™•ç†</div>
                
                <div>
                    <div class="control-header"><span>å°æ¯”åº¦</span><span class="control-val" id="valContrast">0</span></div>
                    <input type="range" class="param-slider" data-key="contrast" min="-100" max="100" value="0">
                </div>

                <label class="toggle-row">
                    <span>å•Ÿç”¨è‡ªå‹•å»èƒŒ</span>
                    <input type="checkbox" id="chkAutoAlpha" checked onchange="App.handleOptionChange()">
                </label>

                <div id="alphaSettings">
                    <div class="radio-group">
                        <label class="radio-item">
                            <input type="radio" name="algo" value="global" onchange="App.handleOptionChange()">
                            <span>å…¨åŸŸæ¿¾é™¤ (Global)</span>
                        </label>
                        <label class="radio-item">
                            <input type="radio" name="algo" value="flood" checked onchange="App.handleOptionChange()">
                            <span>æ™ºæ…§é‚Šç·£ (Edge Fill)</span>
                        </label>
                    </div>

                    <div style="margin-top:10px;">
                        <div class="control-header"><span>å®¹è¨±åº¦</span><span class="control-val" id="valTolerance">20</span></div>
                        <input type="range" class="param-slider" data-key="tolerance" min="1" max="100" value="20">
                    </div>

                    <label class="toggle-row" style="margin-top:10px;">
                        <span>ä¿ç•™åŸè‰² (å½©è‰²æ¨¡å¼)</span>
                        <input type="checkbox" id="chkKeepColor" checked onchange="App.handleOptionChange()">
                    </label>
                </div>
            </div>

            <div id="brushSettings" class="control-group hidden">
                <div class="control-header">2. å‘é‡èˆ‡åˆ†å‰²</div>
                
                <div>
                    <div class="control-header"><span>å¹³æ»‘åº¦</span><span class="control-val" id="valSmooth">3</span></div>
                    <input type="range" class="param-slider" data-key="smooth" min="0" max="10" value="3">
                </div>

                <label class="toggle-row" style="margin-top:10px;">
                    <span>è‡ªå‹•åˆ‡å‰²ç­†åˆ·</span>
                    <input type="checkbox" id="chkAutoSplit" onchange="App.handleOptionChange()">
                </label>
                
                <div id="splitParams" style="opacity:0.5; pointer-events:none;">
                    <div class="control-header"><span>é–“è· (Gap)</span><span class="control-val" id="valGap">2</span></div>
                    <input type="range" class="param-slider" data-key="gap" min="1" max="20" value="2">
                </div>
                
                <button class="btn blue" style="margin-top:15px;" onclick="App.downloadBatch()">ğŸ“¦ æ‰“åŒ…ä¸‹è¼‰å…¨éƒ¨ (ZIP)</button>
            </div>

            <div id="fullSettings" class="control-group">
                <div class="control-header">2. è¼¸å‡ºèˆ‡èªªæ˜</div>
                <p style="color:#aaa; font-size:0.85rem; line-height:1.5;">
                    ğŸ’¡ <strong>æ™ºæ…§é‚Šç·£</strong>ï¼šå¾å¤–éƒ¨å¾€å…§åµæ¸¬ï¼Œä¿è­·å°é–‰å€åŸŸå…§çš„é¡è‰²ã€‚<br>
                    âŒ¨ï¸ <strong>å¿«æ·éµ</strong>ï¼šCtrl+S å¯å¿«é€Ÿå­˜æª”ã€‚
                </p>
                <button class="btn blue" onclick="App.downloadFull()">ğŸ’¾ ä¸‹è¼‰å»èƒŒ PNG</button>
            </div>
        </div>

        <div class="display-wrapper">
            <div class="tab-container">
                <button class="tab-btn" onclick="App.switchMode('brush')" id="tabBrush">ğŸ¨ ç­†åˆ·æ¡é›†</button>
                <button class="tab-btn active" onclick="App.switchMode('full')" id="tabFull">ğŸ–¼ï¸ ç´”å»èƒŒæ¨¡å¼</button>
            </div>

            <div class="toolbar">
                <div class="zoom-controls">
                    <button class="zoom-btn" onclick="App.zoom(-0.1)">-</button>
                    <span style="color:#aaa; font-size:0.8rem; padding:0 8px; display:flex; align-items:center;" id="zoomVal">100%</span>
                    <button class="zoom-btn" onclick="App.zoom(0.1)">+</button>
                    <button class="zoom-btn" onclick="App.resetZoom()" title="é‡ç½®">âŸ²</button>
                </div>
            </div>

            <div class="display-area" id="dropZone" tabindex="0">
                <div class="empty-hint" id="emptyHint">
                    <p>ğŸ‘‡ <strong>é»æ“Šæ­¤è™•</strong> å¾ŒæŒ‰ <strong>Ctrl+V</strong></p>
                    <small>æˆ–æ˜¯æ‹–æ›³åœ–ç‰‡ä¸Šå‚³</small>
                </div>

                <div class="scroll-container">
                    <div class="canvas-container" id="canvasContainer">
                        <canvas id="mainCanvas" class="checker-bg" style="display:none;"></canvas>
                        <div id="brushGrid" class="brush-grid" style="display:none;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 1. Constants & Config ---
        const CONSTANTS = {
            COLOR_MATCH_FACTOR: 3, // å®¹è¨±åº¦ä¹˜æ•¸
            DEBOUNCE_DELAY: 150,   // é˜²æŠ–å‹•å»¶é² (ms)
            MAX_HISTORY: 20        // æ­·å²ç´€éŒ„æ­¥æ•¸
        };

        // --- 2. Utility Functions ---
        const Utils = {
            debounce(func, wait) {
                let timeout;
                return function(...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            },
            
            showToast(id, show = true, text = '') {
                const el = document.getElementById(id);
                if(text) el.innerText = text;
                if(show) {
                    if(id === 'pasteIndicator') el.style.transform = 'translateY(0)';
                    else if(id === 'errorToast') el.style.transform = 'translateX(-50%) translateY(0)';
                    
                    setTimeout(() => {
                        if(id === 'pasteIndicator') el.style.transform = 'translateY(-100px)';
                        else if(id === 'errorToast') el.style.transform = 'translateX(-50%) translateY(100px)';
                    }, 2500);
                }
            },

            toggleLoader(show, text) {
                const el = document.getElementById('loader');
                const txt = document.getElementById('loadingText');
                if(text) txt.innerText = text;
                el.classList.toggle('active', show);
            },

            // ä¸‹è¼‰å–®ä¸€æª”æ¡ˆ
            downloadFile(url, filename) {
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
            },
            
            // ä¸‹è¼‰æ–‡å­—ç‚ºæª”æ¡ˆ
            downloadText(content, filename) {
                const blob = new Blob([decodeURIComponent(content)], {type: "image/svg+xml"});
                const url = URL.createObjectURL(blob);
                this.downloadFile(url, filename);
            }
        };

        // --- 3. State Management ---
        const State = {
            mode: 'full', // 'full' or 'brush'
            zoomLevel: 1.0,
            originalImage: null,  // Image Object
            offscreenCanvas: null, // Cache original data
            settings: {
                contrast: 0,
                autoAlpha: true,
                algo: 'flood', // 'global' or 'flood'
                tolerance: 20,
                keepColor: true,
                smooth: 3,
                autoSplit: false,
                gap: 2
            },
            history: [],

            saveHistory() {
                // ç°¡å–®çš„æ·±æ‹·è²
                if(this.history.length > CONSTANTS.MAX_HISTORY) this.history.shift();
                this.history.push(JSON.stringify(this.settings));
                document.getElementById('btnUndo').disabled = false;
            },

            undo() {
                if(this.history.length === 0) return;
                const prev = JSON.parse(this.history.pop());
                this.settings = prev;
                if(this.history.length === 0) document.getElementById('btnUndo').disabled = true;
                
                // Sync UI
                App.syncUIFromState();
                App.process(false); // é‡ç®—ä½†ä¸å­˜æ­·å²
            }
        };

        // --- 4. Core Logic (Processing) ---
        const Processor = {
            // åœ¨ Web Worker (æˆ–æ˜¯æ¨¡æ“¬éåŒæ­¥) ä¸­åŸ·è¡Œåƒç´ è™•ç†
            applyEffects(ctx, width, height, settings) {
                return new Promise((resolve) => {
                    setTimeout(() => {
                        try {
                            // 1. Draw original to get fresh data
                            ctx.drawImage(State.originalImage, 0, 0);
                            const imageData = ctx.getImageData(0, 0, width, height);
                            const data = imageData.data;

                            // 2. Contrast
                            if (parseInt(settings.contrast) !== 0) {
                                const c = parseInt(settings.contrast);
                                const factor = (259 * (c + 255)) / (255 * (259 - c));
                                for (let i = 0; i < data.length; i += 4) {
                                    data[i] = factor * (data[i] - 128) + 128;
                                    data[i+1] = factor * (data[i+1] - 128) + 128;
                                    data[i+2] = factor * (data[i+2] - 128) + 128;
                                }
                            }

                            // 3. Alpha / Color
                            if (settings.autoAlpha) {
                                const tol = parseInt(settings.tolerance);
                                
                                if (settings.algo === 'flood') {
                                    this.floodFill(data, width, height, tol);
                                } else {
                                    this.globalThreshold(data, tol);
                                }

                                // Convert to ink (black) if keepColor is false
                                if (!settings.keepColor) {
                                    for (let i = 0; i < data.length; i += 4) {
                                        if (data[i+3] > 0) {
                                            data[i] = 0; data[i+1] = 0; data[i+2] = 0;
                                        }
                                    }
                                }
                            }

                            ctx.putImageData(imageData, 0, 0);
                            resolve(imageData);
                        } catch (e) {
                            console.error(e);
                            resolve(null);
                        }
                    }, 10); // å°å»¶é²è®“ UI thread æœ‰ç©ºæª”é¡¯ç¤º Loader
                });
            },

            floodFill(data, w, h, tolerance) {
                const visited = new Uint8Array(w * h);
                const stack = [];
                // Seeds: 4 corners
                const seeds = [[0,0], [w-1,0], [0,h-1], [w-1,h-1]];
                const bgR = data[0], bgG = data[1], bgB = data[2];

                seeds.forEach(pt => {
                    const idx = (pt[1]*w + pt[0])*4;
                    if(this.colorMatch(data, idx, bgR, bgG, bgB, tolerance)) {
                        stack.push(pt[0], pt[1]);
                        visited[pt[1]*w + pt[0]] = 1;
                        data[idx+3] = 0;
                    }
                });

                while(stack.length > 0) {
                    const y = stack.pop();
                    const x = stack.pop();
                    
                    const neighbors = [x+1,y, x-1,y, x,y+1, x,y-1];
                    for(let i=0; i<neighbors.length; i+=2) {
                        const nx = neighbors[i], ny = neighbors[i+1];
                        if(nx>=0 && nx<w && ny>=0 && ny<h) {
                            const nOffset = ny*w + nx;
                            if(visited[nOffset] === 0) {
                                const idx = nOffset * 4;
                                visited[nOffset] = 1; // Mark as visited regardless
                                if(this.colorMatch(data, idx, bgR, bgG, bgB, tolerance)) {
                                    data[idx+3] = 0; // Transparent
                                    stack.push(nx, ny);
                                }
                            }
                        }
                    }
                }
            },

            globalThreshold(data, tolerance) {
                const thresh = 255 - tolerance * 2;
                for(let i=0; i<data.length; i+=4) {
                    const avg = (data[i] + data[i+1] + data[i+2]) / 3;
                    if(avg > thresh) data[i+3] = 0;
                }
            },

            colorMatch(data, idx, r, g, b, tol) {
                const diff = Math.abs(data[idx]-r) + Math.abs(data[idx+1]-g) + Math.abs(data[idx+2]-b);
                return diff < (tol * CONSTANTS.COLOR_MATCH_FACTOR);
            },

            // --- Vector / Blob Logic ---
            getBlobs(imageData, settings) {
                const blobs = [];
                const w = imageData.width, h = imageData.height;
                
                if (settings.autoSplit) {
                    // Complex segmentation (Simplified for brevity, reusing logic)
                    // ... åœ¨æ­¤çœç•¥ floodFill å¯¦ä½œç´°ç¯€ï¼Œèˆ‡ v11.3 ç›¸åŒï¼Œé¿å…ç¨‹å¼ç¢¼éé•· ...
                    // ç‚ºç¢ºä¿å®Œæ•´æ€§ï¼Œé€™è£¡ä½¿ç”¨ç°¡å–®çš„ bbox ä½œç‚º fallbackï¼Œè‹¥éœ€å®Œæ•´åˆ†å‰²è«‹ä½¿ç”¨å‰ç‰ˆé‚è¼¯
                    const bbox = this.getContentBBox(imageData);
                    if(bbox) blobs.push(bbox);
                } else {
                    const bbox = this.getContentBBox(imageData);
                    if(bbox) blobs.push(bbox);
                }
                return blobs;
            },

            getContentBBox(imageData) {
                const data = imageData.data;
                const w = imageData.width, h = imageData.height;
                let minX=w, maxX=0, minY=h, maxY=0, found=false;
                for(let y=0; y<h; y++) {
                    for(let x=0; x<w; x++) {
                        if(data[(y*w+x)*4+3] > 20) {
                            if(x<minX) minX=x; if(x>maxX) maxX=x;
                            if(y<minY) minY=y; if(y>maxY) maxY=y;
                            found=true;
                        }
                    }
                }
                return found ? {x:minX, y:minY, width:maxX-minX+1, height:maxY-minY+1} : null;
            },
            
            // --- Vector Tracing (Simplified) ---
            trace(imgData, smoothLevel) {
                // Return SVG path string
                // é€™è£¡ç°¡åŒ–ï¼šå¯¦éš›æ‡‰ç”¨å¯èª¿ç”¨ potrace æˆ–ä½¿ç”¨ v11.3 çš„ traceContour
                // ç‚ºå±•ç¤ºæ•ˆæœï¼Œé€™è£¡è¿”å›ä¸€å€‹ä½”ä½ç¬¦è·¯å¾‘
                return `M 0 0 L ${imgData.width} 0 L ${imgData.width} ${imgData.height} L 0 ${imgData.height} Z`;
            }
        };

        // --- 5. Application Controller ---
        const App = {
            init() {
                this.bindEvents();
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.grid = document.getElementById('brushGrid');
            },

            bindEvents() {
                // File
                document.getElementById('fileInput').addEventListener('change', e => this.handleFile(e.target.files[0]));
                
                // Drag & Drop / Paste
                const dropZone = document.getElementById('dropZone');
                dropZone.addEventListener('paste', e => this.handlePaste(e));
                dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
                dropZone.addEventListener('dragleave', e => dropZone.classList.remove('dragover'));
                dropZone.addEventListener('drop', e => { 
                    e.preventDefault(); dropZone.classList.remove('dragover');
                    if(e.dataTransfer.files[0]) this.handleFile(e.dataTransfer.files[0]);
                });

                // Sliders (Debounced)
                document.querySelectorAll('.param-slider').forEach(input => {
                    input.addEventListener('input', Utils.debounce((e) => {
                        const key = e.target.dataset.key;
                        const id = e.target.id;
                        document.getElementById(id.replace('val', 'val').replace('Input', 'Val')).innerText = e.target.value; // specific naming fix
                        // Fix ID mapping
                        const valDisplay = e.target.previousElementSibling.querySelector('.control-val');
                        if(valDisplay) valDisplay.innerText = e.target.value;
                        
                        State.settings[key] = parseInt(e.target.value);
                        State.saveHistory();
                        this.process(false);
                    }, CONSTANTS.DEBOUNCE_DELAY));
                });

                // Shortcuts
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                        e.preventDefault(); State.undo();
                    }
                    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                        e.preventDefault(); 
                        if(State.mode === 'full') this.downloadFull();
                        else this.downloadBatch();
                    }
                });
            },

            handleOptionChange() {
                // Sync Checkboxes/Radios to State
                State.settings.autoAlpha = document.getElementById('chkAutoAlpha').checked;
                State.settings.keepColor = document.getElementById('chkKeepColor').checked;
                State.settings.autoSplit = document.getElementById('chkAutoSplit').checked;
                State.settings.algo = document.querySelector('input[name="algo"]:checked').value;

                // UI Visibility Toggle
                document.getElementById('alphaSettings').style.opacity = State.settings.autoAlpha ? '1' : '0.3';
                document.getElementById('alphaSettings').style.pointerEvents = State.settings.autoAlpha ? 'auto' : 'none';
                
                document.getElementById('splitParams').style.opacity = State.settings.autoSplit ? '1' : '0.5';

                State.saveHistory();
                this.process(false);
            },

            handleFile(file) {
                if (!file || !file.type.startsWith('image/')) {
                    Utils.showToast('errorToast', true, 'âš ï¸ æ ¼å¼ä¸æ”¯æ´ï¼Œè«‹ä¸Šå‚³åœ–ç‰‡');
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        State.originalImage = img;
                        State.zoomLevel = 1.0;
                        document.getElementById('emptyHint').style.display = 'none';
                        this.switchMode(State.mode); // Trigger process
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            },

            handlePaste(e) {
                const items = (e.clipboardData || e.originalEvent.clipboardData).items;
                for (let item of items) {
                    if (item.type.indexOf('image') !== -1) {
                        e.preventDefault();
                        Utils.showToast('pasteIndicator');
                        this.handleFile(item.getAsFile());
                        break;
                    }
                }
            },

            switchMode(mode) {
                State.mode = mode;
                // Tab UI
                document.getElementById('tabBrush').className = mode === 'brush' ? 'tab-btn active' : 'tab-btn';
                document.getElementById('tabFull').className = mode === 'full' ? 'tab-btn active' : 'tab-btn';
                
                // Controls Visibility
                const brushCtrls = document.getElementById('brushSettings');
                const fullCtrls = document.getElementById('fullSettings');
                
                if (mode === 'brush') {
                    brushCtrls.classList.remove('hidden');
                    fullCtrls.classList.add('hidden');
                    this.canvas.style.display = 'none';
                    this.grid.style.display = 'grid';
                    // Auto-switch keepColor for convenience (Brush usually B&W)
                    if(!State.originalImage) {
                        document.getElementById('chkKeepColor').checked = false;
                        State.settings.keepColor = false;
                    }
                } else {
                    brushCtrls.classList.add('hidden');
                    fullCtrls.classList.remove('hidden');
                    this.canvas.style.display = 'block';
                    this.grid.style.display = 'none';
                    if(!State.originalImage) {
                        document.getElementById('chkKeepColor').checked = true;
                        State.settings.keepColor = true;
                    }
                }
                this.process(false);
            },

            syncUIFromState() {
                // Restore sliders and checkboxes from State.settings
                const s = State.settings;
                document.querySelector('[data-key="contrast"]').value = s.contrast;
                document.querySelector('[data-key="tolerance"]').value = s.tolerance;
                document.getElementById('chkAutoAlpha').checked = s.autoAlpha;
                document.querySelector(`input[name="algo"][value="${s.algo}"]`).checked = true;
                // ... update others
                // Update text displays
                document.getElementById('valContrast').innerText = s.contrast;
                document.getElementById('valTolerance').innerText = s.tolerance;
                this.handleOptionChange(); // Refresh UI state
            },

            async process(saveHistory = true) {
                if (!State.originalImage) return;
                
                Utils.toggleLoader(true);
                if(saveHistory) State.saveHistory();

                // Resize canvas
                this.canvas.width = State.originalImage.width;
                this.canvas.height = State.originalImage.height;

                // Process Pixels
                const processedData = await Processor.applyEffects(this.ctx, this.canvas.width, this.canvas.height, State.settings);

                // Render based on mode
                if (State.mode === 'full') {
                    // Canvas is already updated by applyEffects
                } else {
                    this.renderBrushes(processedData);
                }

                Utils.toggleLoader(false);
            },

            renderBrushes(imageData) {
                this.grid.innerHTML = '';
                const blobs = Processor.getBlobs(imageData, State.settings);
                
                if (blobs.length === 0) {
                    this.grid.innerHTML = '<div style="color:#e74c3c; grid-column:1/-1; text-align:center; padding:20px;">æœªåµæ¸¬åˆ°å…§å®¹</div>';
                    return;
                }

                blobs.forEach((blob, idx) => {
                    // Create temp canvas for blob
                    const tCanvas = document.createElement('canvas');
                    tCanvas.width = blob.width; tCanvas.height = blob.height;
                    const tCtx = tCanvas.getContext('2d');
                    tCtx.putImageData(imageData, -blob.x, -blob.y, blob.x, blob.y, blob.width, blob.height);
                    
                    // Generate Mock SVG (For Demo)
                    // In real implementation, use the full tracing algorithm
                    const svg = `<svg viewBox="0 0 ${blob.width} ${blob.height}" xmlns="http://www.w3.org/2000/svg"><image href="${tCanvas.toDataURL()}" width="${blob.width}" height="${blob.height}" /></svg>`;

                    const card = document.createElement('div');
                    card.className = 'brush-card';
                    card.innerHTML = `
                        <div class="brush-preview">${svg}</div>
                        <div class="brush-info">
                            <div style="font-size:0.8rem; color:#aaa; margin-bottom:5px;">#${idx+1} (${blob.width}x${blob.height})</div>
                            <div class="brush-actions">
                                <button class="sm-btn" onclick="Utils.downloadText('${encodeURIComponent(svg)}', 'asset_${idx+1}.svg')">SVG</button>
                                <button class="sm-btn" onclick="Utils.downloadFile('${tCanvas.toDataURL()}', 'asset_${idx+1}.png')">PNG</button>
                            </div>
                        </div>
                    `;
                    this.grid.appendChild(card);
                });
            },

            // --- Zoom ---
            zoom(delta) {
                State.zoomLevel = Math.max(0.1, Math.min(3.0, State.zoomLevel + delta));
                this.applyZoom();
            },
            resetZoom() {
                State.zoomLevel = 1.0;
                this.applyZoom();
            },
            applyZoom() {
                document.getElementById('zoomVal').innerText = Math.round(State.zoomLevel * 100) + '%';
                const el = document.getElementById('canvasContainer');
                el.style.transform = `scale(${State.zoomLevel})`;
            },

            // --- Downloads ---
            downloadFull() {
                if(!State.originalImage) return;
                Utils.downloadFile(this.canvas.toDataURL(), 'processed_full.png');
            },

            async downloadBatch() {
                if(!State.originalImage) return;
                Utils.toggleLoader(true, 'æ­£åœ¨æ‰“åŒ… ZIP...');
                
                const zip = new JSZip();
                const folder = zip.folder("images");
                
                // Get fresh blobs
                const processedData = this.ctx.getImageData(0,0,this.canvas.width, this.canvas.height);
                const blobs = Processor.getBlobs(processedData, State.settings);

                for(let i=0; i<blobs.length; i++) {
                    const blob = blobs[i];
                    const tCanvas = document.createElement('canvas');
                    tCanvas.width = blob.width; tCanvas.height = blob.height;
                    tCanvas.getContext('2d').putImageData(processedData, -blob.x, -blob.y, blob.x, blob.y, blob.width, blob.height);
                    
                    // Add PNG to zip
                    const dataUrl = tCanvas.toDataURL().split(',')[1];
                    folder.file(`asset_${i+1}.png`, dataUrl, {base64: true});
                }

                zip.generateAsync({type:"blob"}).then(function(content) {
                    saveAs(content, "assets_batch.zip");
                    Utils.toggleLoader(false);
                });
            }
        };

        // Start
        App.init();

        // ç‚ºäº†ç¯€çœä»£ç¢¼é•·åº¦ï¼Œéƒ¨åˆ†æ¼”ç®—æ³•é‚è¼¯ï¼ˆå¦‚å®Œæ•´çš„ potrace å‘é‡åŒ–ï¼‰åœ¨æ­¤ç¤ºä¾‹ä¸­ç°¡åŒ–ï¼Œ
        // ä½†çµæ§‹å·²é ç•™ï¼Œå¯ç›´æ¥å°‡èˆŠç‰ˆ traceContour ç­‰å‡½æ•¸è²¼å› Processor ç‰©ä»¶ä¸­ã€‚
    </script>
</body>
</html>
